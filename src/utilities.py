import os
import ocrmypdf
import shutil
import re
import openpyxl
import pandas as pd
import pdfplumber.table

reserved_table_keyword = 'REServed_table'


# Helper functions


def create_dir(directory: str):
    """Creates a directory if it does not exist already. If the directory
    exists, does nothing.

    Parameters:
        directory (str): A string containing file directory to create

    Returns:
        None
    """
    if not os.path.exists(directory):
        os.makedirs(directory)


def delete_file(file_dir):
    if os.path.exists(file_dir):
        os.remove(file_dir)


def delete_dir(directory):
    if os.path.exists(directory):
        shutil.rmtree(directory)


def ocr_pdfs(pdf_filepaths: list, output_dir: str) -> None:
    """
    This function applies OCR (Optical Character Recognition) to PDFs. It will
    skip text in PDFs and only apply OCR to images. The skipped text is preserved in-
    place.

    Output PDFs are saved with the name "OCR_" + input file name. Existing files will be
    overwritten.

    Parameters:
        pdf_filepaths (list): A list or tuple with filepaths of input PDFs.
        output_dir (str): Output directory to save the OCR-ed PDFs.

    Returns:
        None
    """

    output_folder = os.path.join(output_dir, 'OCR_')

    delete_dir(output_folder)
    create_dir(output_folder)

    for pdf in pdf_filepaths:
        output_file = os.path.join(output_folder, os.path.basename(pdf))

        if os.path.exists(output_file):
            delete_dir(output_file)

        ocrmypdf.ocr(input_file=pdf, output_file=output_file, skip_text=True)


def remove_cid_text(text: str) -> str:

    """ This function removes cid string artifacts from text generated by applying OCR to PDFs.

    Parameters:
        text (str): Raw text of PDF with OCR applied.

    Returns:
        str: Text without cid artifacts
    """

    return re.sub(r"(\(cid:\d*\))", "", text)


def extract_table_text(page: pdfplumber.pdf.Page, table: pdfplumber.table.Table) -> str:

    """ This function uses the page.crop() method from a pdfplumber page object to crop a page to the
    specified table , and then extracts the text from the resulting cropped page.

    Parameters:
        page (pdfplumber.pdf.Page): PDFPlumber page object to be cropped.
        table (pdfplumber.table.Table): Table object generated by page.find_tables() function.

    Returns:
        str: Raw text from input table.
    """
    return page.crop(table.bbox).extract_text()


def remove_table_text(page_text, table_text, table_number):
    updated_text = page_text.replace(table_text, f".\n{reserved_table_keyword} TABLE {table_number}.png.\n")
    return updated_text


def table_to_image(page,
                   table,
                   doc_name,
                   table_number,
                   save_location,
                   img_extension='png'):
    cell_table_text = f"TABLE {doc_name} {table_number}.{img_extension}"
    table_filepath = os.path.join(save_location, cell_table_text)
    page.crop(table.bbox).to_image(resolution=100).save(table_filepath)


def create_df(doc_col, heading1_col, heading2_col, requirement_col):
    return pd.DataFrame(columns=[str(doc_col), str(heading1_col), str(heading2_col), str(requirement_col)])


def req_under_heading(
        previous_heading_tuple, current_heading_tuple, requirement_tuple, last_heading=False
):
    """Function checks if the requirement sits after previous_heading and before current_heading."""
    if last_heading:
        if requirement_tuple[0] > current_heading_tuple[1]:
            return True
    else:
        if previous_heading_tuple[1] < requirement_tuple[0] < current_heading_tuple[1]:
            return True
        else:
            return False


def find_img_name_in_cell(cell,
                          img_extension='.png'
                          ):
    a = cell.value.find(reserved_table_keyword) + len(reserved_table_keyword)
    b = cell.value.find(img_extension) + len(img_extension)

    img_name = cell.value[a:b].strip()

    return img_name


def insert_img_to_cell(img_dir,
                       cell,
                       ws
                       ):
    img = openpyxl.drawing.image.Image(img_dir)
    img.anchor = str(cell.coordinate)
    ws.add_image(img)


def post_process_sheet(
        sheet_dir,
        extract_tables=True,
        img_folder=None,
        table_text='Inserted_Table'
):
    wb = openpyxl.load_workbook(sheet_dir)
    ws = wb.active
    if extract_tables and img_folder is None:
        raise ValueError('Require a directory for table_folder if extract_tables is True.')

    # Replace reserved table keyword with an image of the table...

    for row in ws.rows:
        for cell in row:
            if cell.value is not None:

                cell.value = str(cell.value).strip()

                if reserved_table_keyword in str(cell.value):
                    if extract_tables:
                        img_name = find_img_name_in_cell(cell)
                        img_dir = os.path.join(img_folder, img_name)
                        insert_img_to_cell(img_dir, cell, ws)
                    # to do - make sure you fix table replacement. Might have to write a function to split a cell
                    # where the table text is found. That way no funny text replacement early in the pipeline
                    cell.value = table_text

    wb.save("dataframe.xlsx")


def df_to_excel(df, output_file, extract_tables=False):
    temp_image_folder = os.getcwd()

    delete_file(output_file)
    df.to_excel(output_file)
    post_process_sheet(output_file, extract_tables=extract_tables, img_folder=temp_image_folder)
